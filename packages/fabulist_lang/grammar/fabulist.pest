// SILENT RULES
WHITESPACE = _{ " " | "\n" }

// KEYWORDS
true_keyword   = _{ "true" }
false_keyword  = _{ "false" }
none_keyword   = _{ "none" }
meta_keyword   = _{ "story" }
if_keyword     = _{ "if" }
else_keyword   = _{ "else" }
return_keyword = _{ "return" }
import_keyword = _{ "keyword" }
from_keyword   = _{ "from" }
keyword        = _{
    true_keyword
  | false_keyword
  | none_keyword
  | meta_keyword
  | import_keyword
  | from_keyword
}

// PRIMITIVE VALUE
string_interior     = ${ (!("\"") ~ ANY)* }
string              = ${ "\"" ~ string_interior ~ "\"" }
raw_string_interior = ${ (!("\"" ~ PEEK) ~ ANY)* }
raw_string          = ${ "r" ~ PUSH("#"*) ~ "\"" ~ raw_string_interior ~ "\"" ~ POP }
number              = ${ ASCII_DIGIT+ }
boolean             = ${ true_keyword | false_keyword }
none                = ${ none_keyword }
identifier          = ${ !keyword ~ "_"? ~ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "_")* }
kebab_identifier    = ${ !keyword ~ "_"? ~ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "_" | "-")* }

// OPERATORS
unary_operator      = { "!" | "-" }
factor_operator     = { "/" | "*" }
term_operator       = { "-" | "+" }
comparison_operator = { ">=" | "<=" | ">" | "<" }
equality_operator   = { "!=" | "==" }
logical_operator    = { "&&" | "||" }

// DEFINITIONS
parameters      = { identifier ~ ("," ~ identifier)* }
arguments       = { expression ~ ("," ~ expression)* }
object_interior = { string ~ ":" ~ expression ~ ("," ~ string ~ ":" ~ expression)* }
object          = { "{" ~ object_interior? ~ "}" }
statement_body  = { "{" ~ control_statement* ~ "}" }
grouping        = { "(" ~ expression ~ ")" }
argument_body   = { "(" ~ arguments? ~ ")" }
parameter_body  = { "(" ~ parameters? ~ ")" }
lambda_function = { parameter_body ~ "=>" ~ statement_body }

// EXPRESSIONS
primary    = _{
    raw_string
  | string
  | number
  | boolean
  | lambda_function
  | grouping
  | none
  | identifier
  | object
}
call       =  { #callee = primary ~ argument_body* }
unary      =  { (#operator = unary_operator ~ #right = unary) | call }
factor     =  { #left = unary ~ (#operator = factor_operator ~ #right = unary)* }
term       =  { #left = factor ~ (#operator = term_operator ~ #right = factor)* }
comparison =  { #left = term ~ (#operator = comparison_operator ~ #right = term)* }
equality   =  { #left = comparison ~ (#operator = equality_operator ~ #right = comparison)* }
logical    =  { #left = equality ~ (#operator = logical_operator ~ #right = equality)* }
expression =  { logical }

// CONTROL STATEMENTS
import_statement     = { import_keyword ~ #name = identifier ~ from_keyword ~ #path = string ~ ";" }
expression_statement = { expression ~ ";" }
assignment_statement = { #name = identifier ~ #value = expression ~ ";" }
var_decl_statement   = { "let" ~ #name = identifier ~ #value = expression ~ ";" }
return_statement     = { return_keyword ~ #value = expression ~ ";" }
else_block           = { else_keyword ~ statement_body }
else_if_block        = { else_keyword ~ if_keyword ~ #condition = grouping ~ statement_body }
if_block             = { if_keyword ~ #condition = grouping ~ statement_body }
if_else_statement    = { if_block ~ else_if_block* ~ else_block? }

// ELEMENT DEFINITIONS
character     = { "[" ~ #name = kebab_identifier ~ "]" }
id            = { "#" ~ #name = kebab_identifier }
choice        = { "-" ~ #text = string ~ ("=>" ~ object)? }
narration     = { "*" ~ #text = string ~ ("=>" ~ object)? }
dialogue_body = { ">" ~ #text = string ~ ("=>" ~ object)? }
dialogue      = { #char = character ~ dialogue_body+ }
element       = { dialogue | choice | narration }

// STATEMENTS
part_statement    =  { #id = id ~ element* }
meta_statement    =  { meta_keyword ~ object }
control_statement = _{
    assignment_statement
  | if_else_statement
  | return_statement
  | import_statement
  | var_decl_statement
  | expression_statement
}
statement         =  { part_statement }

fabulist = { SOI ~ meta_statement? ~ statement* ~ EOI }
